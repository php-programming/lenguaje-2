# 2.2 Anatomía del Objeto Commit

## Caso de Uso

**Escenario:** Un organismo de certificación de software necesita auditar el código fuente de un dispositivo médico.

**Requisitos de Auditoría:**
1.  **Integridad Verificable:** Deben poder probar matemáticamente que el código fuente que están revisando es exactamente el mismo que se utilizó para compilar el firmware del dispositivo.
2.  **Trazabilidad de Linaje:** Deben poder trazar el historial de cualquier archivo, identificando no solo el commit que lo modificó por última vez, sino también la secuencia de commits (el linaje) que condujo a ese estado.
3.  **Metadatos de Autoría:** Se debe registrar de forma indeleble quién fue el autor de cada cambio y cuándo se realizó.

---

## Deconstrucción de un Commit

Un `commit` en Git no es simplemente un "delta" o un "patch". Es un objeto de datos inmutable con una estructura bien definida, diseñado para satisfacer los estrictos requisitos de auditoría descritos anteriormente.

Un commit es un archivo de texto plano (un `blob` en la terminología de Git) que contiene los siguientes metadatos y punteros:

1.  **Puntero al `tree`:** Un hash SHA-1 que apunta a un objeto `tree`. Un `tree` es la representación de Git de una carpeta o directorio. Este `tree` raíz representa la instantánea completa del proyecto en el momento del commit.
2.  **Puntero(s) al/los `parent(s)`:** El/los hash(es) SHA-1 de los commits padres. Esto es lo que enlaza los commits entre sí, formando el DAG. Un commit de merge tendrá dos o más padres.
3.  **Metadatos de Autoría:**
    *   **Autor:** El nombre y correo electrónico de la persona que escribió originalmente el código.
    *   **Committer:** El nombre y correo electrónico de la persona que realizó el commit (pueden ser diferentes, por ejemplo, al aplicar un parche enviado por correo).
    *   **Timestamps:** Fechas y horas exactas para el autor y el committer.
4.  **Mensaje de Commit:** La explicación en texto plano del propósito del cambio.

### Visualización de la Estructura

```mermaid
graph TD
    subgraph "Objetos en la Base de Datos de Git (.git/objects)"
        Commit_A[Commit fa3a1b2]
        Tree_A[Tree d8329fc]
        Blob_Readme[Blob a54b2f1<br>"# Hola Mundo"]
        Blob_Gitignore[Blob 1a9f3b7<br>"node_modules/"]

        Commit_A -- tree --> Tree_A
        Tree_A -- "README.md" --> Blob_Readme
        Tree_A -- ".gitignore" --> Blob_Gitignore
        Commit_A -- parent --> Commit_Parent(...)
    end

    style Commit_A fill:#FFF5EE,stroke:#D2691E
```


**El Hash SHA-1: El Sello de Integridad**

El identificador de un commit (ej. `fa3a1b2...`) no es un número secuencial, es el **hash SHA-1 de todo su contenido**: el puntero al `tree`, los punteros a los padres, los metadatos de autoría y el mensaje.

**Implicaciones para la Auditoría:**
1.  **Cumplimiento de Integridad:** Si un solo bit cambia en cualquier archivo del proyecto, el hash del `blob` de ese archivo cambia. Esto provoca un cambio en el hash del `tree` que lo contiene, lo que a su vez cambia el hash del `commit`. Por lo tanto, el hash del commit actúa como un **sello criptográfico para todo el estado del proyecto**. El auditor puede simplemente comparar el hash del commit con el proporcionado por el fabricante para verificar la integridad.
2.  **Cumplimiento de Linaje y Autoría:** Como los punteros a los padres son parte del contenido hasheado, el historial es inmutable. No se puede insertar o eliminar un commit del medio de la historia sin invalidar los hashes de todos sus descendientes. La información del autor y el committer está igualmente "sellada" dentro del commit.

**Conclusión:** La arquitectura del objeto `commit` es una obra maestra de diseño para la integridad de datos. Al entender que un commit es un nexo inmutable que une una instantánea completa del proyecto (`tree`), su historia (`parent`) y sus metadatos (autor, mensaje), queda claro cómo Git satisface incluso los requisitos de auditoría más exigentes, proveyendo una base de confianza fundamental para la ingeniería de software crítica.
