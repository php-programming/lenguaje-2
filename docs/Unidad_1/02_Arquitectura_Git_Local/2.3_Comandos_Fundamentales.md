# 2.3 Comandos Fundamentales del Flujo Local

## Caso de Uso

**Escenario:** Una desarrolladora junior, Ana, se une a un proyecto de software. Su primera tarea es implementar una pequeña mejora.

**Flujo de Trabajo Requerido:**
1.  **Orientación:** Ana necesita una forma de inspeccionar el estado actual de su copia de trabajo para entender qué archivos han sido modificados.
2.  **Preparación Selectiva:** Debe ser capaz de seleccionar únicamente los archivos relevantes para su tarea y prepararlos para ser confirmados, ignorando otros archivos temporales o de configuración personal.
3.  **Confirmación Atómica:** Necesita empaquetar sus cambios preparados en un solo commit con un mensaje claro que explique la mejora.
4.  **Verificación Histórica:** Después de hacer el commit, necesita una forma de ver el historial del proyecto para confirmar que su commit ha sido añadido correctamente y entender el contexto de los cambios previos.

---

## Navegando el Modelo de Tres Estados

Los siguientes comandos son el conjunto de herramientas principal para interactuar con el Directorio de Trabajo, el Índice y el Repositorio Local.

### `git status`

Este es el comando de diagnóstico principal. Su función es informar sobre el estado de los tres árboles. Su salida responde a tres preguntas clave:
1.  ¿Qué cambios existen en el **Directorio de Trabajo** que aún no están en el Índice? (`Changes not staged for commit`)
2.  ¿Qué cambios están en el **Índice** y listos para el próximo commit? (`Changes to be committed`)
3.  ¿Qué archivos en el Directorio de Trabajo no están siendo rastreados por Git? (`Untracked files`)

**Aplicación al Caso de Uso:** Ana ejecutaría `git status` constantemente para obtener una visión clara de su trabajo actual.

```bash
# Salida de ejemplo de git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   user_profile.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   database.py

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        notes.txt
```

### `git add <file>`

Este comando transfiere una instantánea del estado actual de un archivo desde el Directorio de Trabajo al **Índice**. Es el acto de "preparar" o "ensayar" (staging) un cambio.

**Aplicación al Caso de Uso:** Si la tarea de Ana solo involucra `user_profile.py`, ejecutaría `git add user_profile.py` para preparar únicamente ese cambio. `database.py` y `notes.txt` permanecerían sin preparar.

### `git commit -m "mensaje"`

Este comando crea un nuevo commit en el **Repositorio Local**. Su contenido será la instantánea exacta de los archivos que residen en el **Índice** en el momento de su ejecución. El contenido del Directorio de Trabajo es, en gran medida, irrelevante para `git commit`.

**Aplicación al Caso de Uso:** Después de preparar sus cambios con `git add`, Ana ejecutaría:
```bash
git commit -m "feat(profile): Add avatar upload functionality"
```
Esto crearía un commit atómico que contiene solo los cambios de `user_profile.py`.

### `git log`

Este comando consulta la base de datos del **Repositorio Local** y muestra el historial de commits en orden cronológico inverso. Permite inspeccionar el DAG, viendo el autor, la fecha y el mensaje de cada commit.

**Aplicación al Caso de Uso:** Para verificar su trabajo, Ana usaría `git log` para ver su nuevo commit en la cima del historial. Opciones como `--oneline` y `--graph` son extremadamente útiles para visualizar el historial de forma más compacta y entender la estructura de las ramas.

```bash
# Salida de ejemplo de git log --oneline --graph
*   a1b2c3d (HEAD -> main) feat(profile): Add avatar upload functionality
*   f4e5d6c refactor: Optimize database connection pool
*   b7c8d9e fix: Correct login validation logic
```

**Conclusión:** Estos cuatro comandos forman el núcleo del "inner loop" del desarrollador en Git. `git status` proporciona la conciencia situacional, `git add` permite la construcción deliberada del próximo commit, `git commit` lo sella en la historia, y `git log` permite auditar el resultado. El dominio de este ciclo es el primer paso práctico para un uso profesional de Git.
