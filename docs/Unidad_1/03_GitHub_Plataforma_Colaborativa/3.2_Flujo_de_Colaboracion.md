# 3.2 El Flujo de Colaboración Central: Pull Requests

## Caso de Uso

**Escenario:** Un equipo de desarrollo de software está construyendo una API REST. Una ingeniera senior, Clara, ha diseñado la arquitectura inicial. Un ingeniero junior, David, tiene la tarea de añadir un nuevo `endpoint` para obtener los datos de un usuario (`/users/{id}`).

**Requisitos del Proceso:**
1.  **Garantía de Calidad:** El nuevo código de David no puede ser integrado directamente en la rama principal (`main`) sin ser revisado. Se debe asegurar que cumple con los estándares de codificación del equipo, que es eficiente y que no introduce bugs.
2.  **Integración Continua (CI):** Antes de que el código sea revisado por un humano, un sistema automatizado debe verificar que el nuevo `endpoint` está cubierto por pruebas unitarias y que todas las pruebas del proyecto siguen pasando.
3.  **Discusión Contextual:** Si Clara encuentra un problema en el código de David, necesita un mecanismo para dejar comentarios en líneas específicas de código y discutir la implementación con David de forma asíncrona.

---

## El Mecanismo de Pull Request (PR)

Un **Pull Request** (o Merge Request en la terminología de GitLab) es el mecanismo fundamental para la colaboración en plataformas como GitHub. Es una **solicitud formal** para que los mantenedores de un proyecto revisen e incorporen una serie de commits de una rama a otra.

No es solo una "solicitud de merge"; es un **espacio de trabajo colaborativo** para una unidad de cambio específica.

### Flujo de Trabajo de un Pull Request

```mermaid
graph TD
    subgraph "Repositorio Local de David (Junior)"
        A[Rama 'main'] -- git checkout -b feature/get-user --> B(Rama 'feature/get-user')
        B -- git commit --> C{Commit 1: Add endpoint logic}
        C -- git commit --> D{Commit 2: Add unit tests}
        D -- git push --> E[Push de la rama a GitHub]
    end

    subgraph "Plataforma GitHub"
        F[Rama 'feature/get-user' en GitHub] -- Crea PR --> G((Pull Request #12))
        G -- "Revisa y comenta" --> H{Revisión de Código de Clara (Senior)}
        G -- "Ejecuta" --> I{Verificaciones de CI (GitHub Actions)}
        H -- "Solicita cambios" --> G
        I -- "Falla ❌" --> G
    end
    
    E --> F

    subgraph "Repositorio Local de David (Iteración)"
        J[Nuevos commits basados en feedback] -- git push --> F
    end

    G -- "Aprueba y Merged" --> K[Código integrado en 'main']

    style G fill:#D5F5E3,stroke:#2ECC71
```


**Resolviendo los Requisitos del Caso de Uso:**

1.  **Garantía de Calidad (Code Review):** Dentro de la interfaz del PR en GitHub, Clara puede ver un `diff` de todos los cambios propuestos por David. Puede navegar por los archivos y dejar comentarios en líneas específicas. Por ejemplo, podría sugerir una forma más eficiente de hacer una consulta a la base de datos. David es notificado, puede responder a los comentarios y enviar nuevos commits a la misma rama para abordar el feedback. El PR se actualiza automáticamente.

2.  **Integración Continua (CI Checks):** En cuanto David crea el PR, un workflow de **GitHub Actions** (configurado previamente) se activa. Este workflow clona el código propuesto, instala las dependencias y ejecuta la suite de pruebas completa. El resultado (éxito o fallo) se reporta directamente en la interfaz del PR. GitHub puede ser configurado para **bloquear la fusión** si los chequeos de CI no pasan, previniendo la introducción de regresiones.

3.  **Discusión Contextual (Conversation Thread):** El PR actúa como un hilo de discusión centralizado para ese cambio. Todos los comentarios, respuestas, nuevos commits y resultados de CI se registran en orden cronológico. Esto crea un registro auditable de las decisiones de diseño y el proceso de revisión que llevaron a la versión final del código.

**Conclusión:** El Pull Request es el pilar del desarrollo de software moderno y colaborativo. Transforma el acto de fusionar código de una operación técnica de Git a un **proceso de ingeniería de calidad**. Asegura que cada cambio sea revisado, probado automáticamente y documentado antes de impactar la base de código principal, satisfaciendo así todos los requisitos de un entorno de desarrollo profesional.
