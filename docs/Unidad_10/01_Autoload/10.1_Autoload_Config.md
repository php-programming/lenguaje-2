# 10.1 Autoload (como archivo de configuración de PHP)

El **Autoloading** es un mecanismo que PHP proporciona para que, cuando se intenta usar una clase que aún no ha sido cargada, el sistema de Autoload (carga automática) localice e incluya el archivo que contiene esa definición de clase.

El objetivo es: Usar `new ProductoModel()` sin escribir `require_once 'modelos/ProductoModel.php';` en cada archivo.

## Concepto Teórico: `spl_autoload_register()`

En lugar de usar la antigua función `__autoload()`, PHP recomienda el uso de `spl_autoload_register()`.

- **¿Qué hace?** Esta función registra una o más funciones como posibles cargadores de clases. Cuando PHP no encuentra una clase, recorre todas las funciones registradas hasta que una de ellas incluye el archivo correcto.
- **Argumento**: Recibe una función callback (puede ser un closure, el nombre de una función o un método de una clase). Esta función callback recibe el nombre de la clase que se busca.

## Implementación Práctica: El Archivo de Configuración de Autoload

Crearemos un archivo principal que se encargará de configurar y registrar nuestra función de Autoload. Usualmente, este archivo está cerca de la raíz del proyecto.

### a. Estructura de Carpetas (Ejemplo a Cargar):

```text
/
├── public/
│   └── index.php  <-- Punto de entrada y donde se inicializa todo
├── core/
│   └── Autoload.php <-- Donde definimos la lógica
├── modelos/
│   └── ProductoModel.php
└── controladores/
    └── ProductoController.php
```

### b. Archivo `core/Autoload.php` (La Lógica del Cargador):

El cargador necesita saber dónde buscar las clases. Definimos los directorios principales (controladores, modelos, etc.) en un array.

```php
<?php
// Directorios donde residen nuestras clases.
// La clave es crucial para organizar las rutas.
$directorios = [
    'modelos/',
    'controladores/',
    // Si tuvieramos clases base, services, helpers, etc.
    'core/'
];

// 1. Definimos la función de carga automática
function cargar_clases($nombre_clase) {
    global $directorios; // Necesitamos acceso a los directorios definidos arriba

    // Convertir el nombre de la clase a un nombre de archivo (ej. ProductoModel -> ProductoModel.php)
    $archivo_clase = $nombre_clase . '.php';

    // 2. Recorrer los directorios conocidos
    foreach ($directorios as $dir) {
        // Construir la ruta completa al archivo
        // NOTA: Usamos __DIR__ para que la ruta sea relativa a este archivo (Autoload.php)
        $ruta_completa = __DIR__ . '/../' . $dir . $archivo_clase;

        // 3. Verificar si el archivo existe
        if (file_exists($ruta_completa)) {
            // 4. Si existe, lo incluimos y la clase queda definida
            require_once $ruta_completa;
            return; // Detenemos la búsqueda
        }
    }
}

// 5. Registrar la función en el sistema de PHP
spl_autoload_register('cargar_clases');

echo "Sistema de Autoload Inicializado.<br>";

?>
```

### c. Uso en el Punto de Entrada

En el archivo principal (`public/index.php`), solo necesitamos incluir el archivo de configuración de Autoload una sola vez.

**Archivo `public/index.php` (Punto de Entrada):**

```php
<?php
// Inclusión única de la configuración de Autoload
require_once '../core/Autoload.php';

// Antes teníamos que hacer: require_once '../controladores/ProductoController.php';

// Ahora, el sistema de Autoload se encarga de encontrar la clase automáticamente:
$controller = new ProductoController();
$controller->listar(); // Esto funciona porque Autoload.php incluyó la clase ProductoController.php

// Esto demuestra la conveniencia:
// PHP vio 'new ProductoController',
// llamó a cargar_clases('ProductoController'),
// la función recorrió 'controladores/',
// encontró el archivo, lo incluyó, ¡y listo!
?>
```

## Resumen y Ventajas

Hemos creado un sistema de carga automática de clases que se basa en un archivo de configuración de PHP, tal como lo solicitaste (sin Composer).

- **Ventaja clave**: Se eliminan cientos de sentencias `require_once` o `include` de todo el proyecto, haciendo que el código sea mucho más limpio, mantenible y escalable.
- **Principio DRY**: Aplicamos el principio "Don't Repeat Yourself" (No te Repitas) al centralizar la carga de clases.
