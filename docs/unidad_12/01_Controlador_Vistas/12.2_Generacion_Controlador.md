# 12.2 Generación de Controlador de Vistas

Para manejar las vistas de forma profesional en POO, crearemos un Controlador de Vistas (`View.php`). Su trabajo será aislar el código de la vista (el HTML) de la lógica del Controlador, permitiendo al Controlador enviar datos de forma segura.

## Implementación Práctica: La Clase Base de Vistas (`View.php`)

### a. Estructura de Carpetas:

```text
/
├── core/
│   └── View.php          <-- CLASE BASE DE VISTAS
└── vistas/
    └── productos/
        └── lista.php   <-- El HTML de la vista
```

### b. Clase `View.php` (Controlador de Vistas):

Esta clase contendrá dos métodos clave: uno para establecer los datos y otro para renderizar (mostrar) el archivo.

```php
<?php
// core/View.php

class View {
    // 1. Array de datos: Guarda los datos que el Controlador quiere enviar a la Vista.
    protected $datos = [];

    // 2. Método para asignar datos: Recibe las variables clave/valor del Controlador.
    public function asignarDatos(array $datos) {
        $this->datos = $datos;
    }

    // 3. Método para renderizar la Vista
    public function render(string $nombre_vista, string $layout = 'layout_principal') {

        // La ruta del archivo de la vista
        $archivo_vista = '../vistas/' . $nombre_vista . '.php';

        if (!file_exists($archivo_vista)) {
            // Manejo de error si la vista no existe
            die("Error: La vista '{$nombre_vista}' no existe.");
        }

        // Extraer los datos: Convierte las claves del array $this->datos
        // en variables locales accesibles dentro del archivo de la vista.
        // Ejemplo: $this->datos['titulo'] se convierte en una variable $titulo
        extract($this->datos);

        // Iniciar el buffer de salida: Captura todo el HTML generado por la vista.
        ob_start();

        // Incluir la vista específica (donde se usan las variables extraídas)
        require $archivo_vista;

        // Obtener el contenido del buffer (el HTML de la vista)
        $contenido = ob_get_clean();

        // 4. Integrar al Layout Principal (Opcional, pero profesional)
        // El layout principal es el esqueleto de HTML que tiene el <head>, <body>, etc.
        $archivo_layout = '../vistas/layouts/' . $layout . '.php';

        if (file_exists($archivo_layout)) {
            // Incluir el layout, el cual usará la variable $contenido.
            require $archivo_layout;
        } else {
            // Si no hay layout, solo imprime el contenido de la vista
            echo $contenido;
        }
    }
}
?>
```

### c. El Controlador Intermediario (Modificación de `ProductoController`)

El Controlador ahora usa la clase `View` para manejar la presentación, cerrando el ciclo M-V-C.

```php
<?php
// controladores/ProductoController.php (Parte Modificada)

// Asumimos que ProductoModel y View están cargados vía Autoload
class ProductoController {

    // ... constructor y modelo ...

    public function listar() {
        // 1. Controlador llama al Modelo y obtiene los datos
        $productos = $this->modelo->obtenerTodos(); // Ejemplo: [ [datos], [datos] ]

        // 2. Controlador prepara los datos (título, mensajes, etc.)
        $datos_para_vista = [
            'titulo' => 'Catálogo de Productos',
            'lista_productos' => $productos // Los datos que vienen del Modelo
        ];

        // 3. Controlador instancia el Controlador de Vistas
        $vista = new View();

        // 4. Controlador asigna los datos a la Vista
        $vista->asignarDatos($datos_para_vista);

        // 5. Controlador renderiza la vista específica 'productos/lista'
        $vista->render('productos/lista');
    }
}
?>
```

## Conclusión

Hemos implementado un Controlador de Vistas basado en POO (`View.php`) que usa la función `extract()` para pasar variables de forma segura a los archivos de vista y `ob_start()` / `ob_get_clean()` para integrar el contenido de la vista en un layout principal.
