# 5.3 Criptografía Aplicada: Hashing de Contraseñas

## Caso de Uso

**Escenario:** Una base de datos de usuarios es filtrada (leaked) en la Dark Web.
**Riesgo:** Si las contraseñas están en texto plano, millones de cuentas están comprometidas inmediatamente.
**Defensa:** Almacenar solo una "huella digital" criptográfica (Hash) de la contraseña.

---

## Hashing vs. Encriptación

Es un error conceptual común confundirlos.

*   **Encriptación (Bidireccional):** Transforma datos con una clave. Se puede revertir (desencriptar) si se tiene la clave. *Uso: Guardar tarjetas de crédito.*
*   **Hashing (Unidireccional):** Transforma datos en una cadena de longitud fija. **No se puede revertir** matemáticamente. *Uso: Guardar contraseñas.*

## Algoritmos Modernos (Bcrypt / Argon2)

Algoritmos antiguos como MD5 o SHA1 son **inseguros** porque son demasiado rápidos. Un atacante puede probar miles de millones de combinaciones por segundo (Fuerza Bruta).

Los algoritmos modernos como **Bcrypt** son deliberadamente lentos ("costosos" computacionalmente) para dificultar los ataques.

### Implementación en PHP

PHP abstrae la complejidad criptográfica con funciones nativas seguras.

**1. Crear el Hash (Al registrarse):**

```php
$password_plano = "MiContraseñaSegura123";

// Crea un hash seguro usando el algoritmo por defecto (actualmente Bcrypt)
// Genera automáticamente una "Salt" aleatoria.
$hash = password_hash($password_plano, PASSWORD_DEFAULT);

// Guardar $hash en la base de datos (VARCHAR 255)
```

**2. Verificar el Hash (Al hacer login):**

```php
$input_login = "MiContraseñaSegura123";
$hash_guardado = $usuario_db['password_hash'];

if (password_verify($input_login, $hash_guardado)) {
    echo "Login exitoso";
} else {
    echo "Contraseña incorrecta";
}
```

**Principio de Ingeniería:** Nunca intente implementar su propio algoritmo de criptografía ("Don't roll your own crypto"). Use siempre las librerías estándar probadas por la industria.
