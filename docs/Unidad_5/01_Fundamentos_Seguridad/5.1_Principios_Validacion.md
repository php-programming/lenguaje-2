# 5.1 Principios de Seguridad y Validación (Input Validation)

## Caso de Uso

**Escenario:** Un formulario de registro público.
**Amenaza:** Un usuario malintencionado intenta registrarse con el email `admin@empresa.com; DROP TABLE users;`.
**Defensa:** El sistema debe rechazar la entrada antes de siquiera intentar procesarla.

---

## La Mentalidad de Seguridad (Zero Trust)

En ingeniería de seguridad, adoptamos una postura paranoica: **"Todo input es culpable hasta que se demuestre lo contrario"**. Nunca confíe en datos provenientes del cliente (GET, POST, COOKIE, Headers).

### La Tríada CIA

1.  **Confidencialidad:** Solo los autorizados ven los datos.
2.  **Integridad:** Los datos no han sido alterados.
3.  **Disponibilidad:** El sistema sigue funcionando.

### Validación vs. Sanitización

*   **Validación:** Verificar si el dato cumple con un formato esperado. Si no, se rechaza. (Ej. "¿Es esto un email válido?").
*   **Sanitización:** Limpiar el dato eliminando caracteres peligrosos. (Ej. Eliminar etiquetas `<script>` de un comentario).

### Expresiones Regulares (Regex)

Regex es la herramienta estándar de la industria para la validación de patrones complejos.

```php
$email = "usuario@dominio.com";
// Patrón simple para email
$patron = "/^[\w\-\.]+@([\w-]+\.)+[\w-]{2,4}$/";

if (preg_match($patron, $email)) {
    echo "Email válido";
} else {
    echo "Formato inválido";
}
```

**Validación de Contraseñas Fuertes:**
Requerir: Mínimo 8 caracteres, al menos una mayúscula, una minúscula y un número.
Regex: `/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/`

**Filtros Nativos de PHP:**
PHP ofrece `filter_var()`, una alternativa más legible y segura para validaciones comunes.
```php
if (filter_var($email, FILTER_VALIDATE_EMAIL)) { ... }
```
